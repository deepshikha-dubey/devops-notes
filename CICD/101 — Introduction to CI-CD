101 — Introduction to CI/CD
Understand Continuous Integration and Continuous Deployment fundamentals, workflows, and benefits for modern software development.

Step 1 Verify GitHub CLI installation
Check if you have the GitHub CLI (gh) installed, which we'll use for CI/CD automation.

Commands to Run
gh --version
gh auth status
What This Does
GitHub CLI (gh) streamlines CI/CD setup with GitHub Actions. CI (Continuous Integration) automatically builds and tests code on every commit. CD (Continuous Deployment) automatically deploys tested code to production. CD (Continuous Delivery) automates deployment to staging with manual production approval.

Expected Outcome
gh CLI version displayed (e.g., 'gh version 2.x.x') and authentication status showing you're logged in to GitHub.

Pro Tips
1 Install gh CLI from https://cli.github.com if not installed
2 Login with: gh auth login
3 CI catches bugs early by testing every commit
4 CD delivers features faster through automation
5 GitHub Actions provides free CI/CD for public repos

Step 2 Create a GitHub repository
Set up a repository for CI/CD practice.

Commands to Run
mkdir cicd-demo && cd cicd-demo
git init
echo '# CI/CD Demo' > README.md
echo 'node_modules/' > .gitignore
git add .
git commit -m 'Initial commit'
gh repo create cicd-demo --public --source=. --remote=origin --push

What This Does
GitHub hosts code and provides CI/CD via GitHub Actions. 'gh' CLI simplifies repo creation.

Expected Outcome
Repository created and pushed to GitHub. Ready for CI/CD setup.

Pro Tips
1 Install gh CLI: https://cli.github.com
2 Alternative: Create repo via github.com UI
3 Public repos get free GitHub Actions minutes
4 Private repos have usage limits

Step 3 Create a simple application
Build a basic app to test with CI/CD.

Commands to Run
cat > index.js << 'EOF'
function add(a, b) {
  return a + b;
}

function subtract(a, b) {
  return a - b;
}

module.exports = { add, subtract };
EOF

cat > index.test.js << 'EOF'
const { add, subtract } = require('./index');

test('adds 1 + 2 to equal 3', () => {
  expect(add(1, 2)).toBe(3);
});

test('subtracts 5 - 2 to equal 3', () => {
  expect(subtract(5, 2)).toBe(3);
});
EOF
npm init -y
npm install --save-dev jest
npm pkg set scripts.test="jest"
npm test

What This Does
Simple Node.js app with tests. CI will run these tests automatically on every commit.

Expected Outcome
App created with passing tests. npm test runs successfully.

Pro Tips
1 Any language works - using Node.js for simplicity
2 Tests are essential for CI
3 Tests should be fast and reliable
4 Add more tests as app grows

Step 4 Understanding pipeline stages
Learn typical CI/CD pipeline phases.

Commands to Run
echo 'Pipeline Stages:
1. Trigger: Code pushed/PR created
2. Build: Compile code, install dependencies
3. Test: Run unit, integration, e2e tests
4. Analyze: Lint, security scan, code quality
5. Package: Create Docker image, artifacts
6. Deploy: Push to dev/staging/production
7. Monitor: Track deployments, rollback if needed'

What This Does
Pipelines automate software delivery through defined stages. Each stage must pass before proceeding.

Expected Outcome
Understanding of pipeline flow from commit to production.

Pro Tips
1 Start simple: build → test → deploy
2 Add stages as needs grow
3 Fail fast: run quick tests first
4 Parallel stages speed up pipeline
5 Each stage should be idempotent

Step 5 Commit and push code
Save work to trigger first CI run.

Commands to Run
git add .
git commit -m 'Add app and tests'
git push origin main

What This Does
Pushing code to main branch. In next lesson, we'll add GitHub Actions to run tests automatically.

Expected Outcome
Code pushed to GitHub. Visible in repository.

Pro Tips
1 Commits to main will trigger CI in next lesson
2 Feature branches can have different CI rules
3 Good commit messages help track changes
4 Push frequently with CI/CD

Step 6 CI/CD best practices overview
Learn key principles for successful CI/CD.

Commands to Run
echo 'Best Practices:
- Commit often (at least daily)
- Keep builds fast (< 10 minutes)
- Test in production-like environments
- Automate everything possible
- Monitor pipeline health
- Fix broken builds immediately
- Use feature flags for incomplete features
- Practice trunk-based development'

What This Does
Following best practices ensures CI/CD delivers value without becoming burden.

Expected Outcome
Understanding of CI/CD principles and practices.

Pro Tips
1 Fast feedback is crucial
2 Broken builds block everyone
3 Automate to reduce human error
4 Monitor and improve pipeline metrics
5 Culture change is as important as tools

Step 7 Understand CI/CD benefits
Recognize value proposition of automation.

Commands to Run
echo 'Benefits:
- Faster time to market
- Fewer bugs in production
- Reduced manual testing effort
- Faster bug fixes and rollbacks
- Improved developer productivity
- Better collaboration
- Continuous feedback
- Reduced deployment risk'

What This Does
CI/CD transforms software delivery. Initial investment pays off with faster, more reliable releases.

Expected Outcome
Clear understanding of why teams adopt CI/CD.

Pro Tips
1 ROI increases over time
2 Catches bugs earlier (cheaper to fix)
3 Enables frequent small releases
4 Reduces deployment stress
5 Improves team confidence

Step 8 CI/CD tools landscape
Survey popular CI/CD platforms. 
Pro Tips
1 GitHub Actions: Best for GitHub repos
2 GitLab CI: Best for GitLab repos
3 Jenkins: Best for self-hosted, complex needs
4 Cloud services: Faster setup, less maintenance

Step 9 Explore GitHub repository insights
View commit history and repository activity.

Commands to Run
gh repo view --web

What This Does
GitHub web UI shows commits, branches, and provides Actions tab (where CI runs appear).

Expected Outcome
Repository opens in browser. Can see commits, files, and Actions tab.

Pro Tips
1 Actions tab will show pipeline runs
2 Commits tab shows all changes
3 Insights show repository activity
4 Settings to configure branch protection
5 We'll add workflows in next lesson

✓ Understand CI/CD concepts and benefits
✓ Know typical pipeline stages
✓ Created a test project
✓ Explored best practices
✓ Surveyed CI/CD tools landscape
