202 â€” Advanced Dockerfile Techniques

Step 1 Understanding multi-stage builds
Learn why multi-stage builds are essential for production images.

Commands to Run
mkdir multi-stage-demo && cd multi-stage-demo
Copy
cat > app.go << 'EOF'
package main
import "fmt"
func main() {
    fmt.Println("Hello from Go!")
}
EOF

cat > Dockerfile.single << 'EOF'
FROM golang:1.21
WORKDIR /app
COPY app.go .
RUN go build -o myapp app.go
CMD ["./myapp"]
EOF

docker build -f Dockerfile.single -t go-app:single .
docker images go-app:single

What This Does
A single-stage build includes the entire Go toolchain in the final image. This results in a ~800MB image for a simple binary that could be just a few MB.

Expected Outcome
The image builds successfully but is very large (800MB+) because it includes the full Go compiler and build tools.

Pro Tips
1 Single-stage builds are simpler but inefficient for compiled languages
2 The final image includes build tools, source code, and dependencies
3 Larger images mean slower deployments and larger attack surface

Step 2 Create your first multi-stage build
Use multiple FROM statements to separate build and runtime stages.

Commands to Run
cat > Dockerfile << 'EOF'
# Stage 1: Build stage
FROM golang:1.21 AS builder
WORKDIR /app
COPY app.go .
RUN go build -o myapp app.go

# Stage 2: Runtime stage
FROM alpine:3.19
WORKDIR /app
COPY --from=builder /app/myapp .
CMD ["./myapp"]
EOF

docker build -t go-app:multi .
docker images | grep go-app

What This Does
Multi-stage builds use multiple FROM statements. Only the final stage becomes the image. COPY --from=builder copies artifacts from the build stage.

Expected Outcome
The multi-stage image is ~10MB vs 800MB for single-stage. Both work identically, but multi-stage is 80x smaller!

Pro Tips
1 Name stages with AS keyword for clarity
2 Only the last FROM determines the final image base
3 Copy only what you need from previous stages
4 Ideal for compiled languages (Go, Rust, C++) and JavaScript builds


Step 3 Multi-stage build for Node.js
Apply multi-stage pattern to a Node.js application with build step.
(Multi-stage builds in Docker allow you to create smaller, cleaner, and more efficient images by using multiple FROM statements in a single Dockerfile. Each stage can have its own base image, and you only copy what you need into the final image.)

Commands to Run
cd .. && mkdir node-multi-stage && cd node-multi-stage

cat > package.json << 'EOF'
{
  "name": "app",
  "scripts": { "build": "echo 'Build completed'" },
  "dependencies": { "express": "^4.18.0" },
  "devDependencies": { "nodemon": "^3.0.0" }
}
EOF

cat > server.js << 'EOF'
const express = require('express');
const app = express();
app.get('/', (req, res) => res.send('Multi-stage Node.js!'));
app.listen(3000, () => console.log('Server ready'));
EOF

cat > Dockerfile << 'EOF'
# Build stage
FROM node:18-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build

# Production stage
FROM node:18-alpine
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY --from=builder /app/server.js .
USER node
CMD ["node", "server.js"]
EOF

docker build -t node-app:multi .

What This Does
Build stage installs all dependencies (including devDependencies). Production stage only installs production dependencies and copies the built artifacts.

Expected Outcome
The final image doesn't include devDependencies like nodemon, reducing size and attack surface.

Pro Tips
1 Separate build and runtime dependencies
2 Build tools (webpack, typescript) stay in build stage
3 Production stage is smaller and more secure
4 Use npm ci in production stage for reproducible installs

step 5 Adding health checks
Configure Docker to monitor container health automatically.

Commands to Run

FROM node:18-alpine
WORKDIR /app
# Install curl for health checks
RUN apk add --no-cache curl
COPY package*.json ./
RUN npm ci --only=production
COPY server.js .
# Health check configuration
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:3000/ || exit 1
USER node
EXPOSE 3000
CMD ["node", "server.js"]

docker build -t node-app:health .
docker run -d -p 3000:3000 --name health-test node-app:health
sleep 10 && docker ps
docker inspect health-test --format='{{.State.Health.Status}}'

What This Does
HEALTHCHECK tells Docker how to test if the container is working. It runs the check command periodically. Status can be: starting, healthy, or unhealthy.

Expected Outcome
After the start period, the container shows 'healthy' status. Docker ps shows health status in STATUS column.

Pro Tips
1 --interval: how often to check (default 30s)
2 --timeout: how long to wait for response (default 30s)
3 --start-period: grace period before first check (default 0s)
4 --retries: failures needed to mark unhealthy (default 3)
5 Exit 0 = healthy, exit 1 = unhealthy
6 Orchestrators like Kubernetes can use this to restart unhealthy containers
