203 — ConfigMaps and Secrets

Step 1 Create a ConfigMap from literal values
Store configuration key-value pairs in a ConfigMap.

Commands to Run
kubectl create configmap app-config --from-literal=APP_ENV=production --from-literal=LOG_LEVEL=info
kubectl get configmap app-config
kubectl describe configmap app-config

What This Does
ConfigMaps store non-sensitive configuration data as key-value pairs. Separate config from application code.

Expected Outcome
ConfigMap created with two keys. Description shows the data stored.

Pro Tips
1 ConfigMaps decouple configuration from container images
2 Enables same image across environments
3 Use for: database URLs, feature flags, app settings
4NOT for sensitive data - use Secrets instead
5 Max size: 1MB per ConfigMap

Step 2 Create ConfigMap from a file
Load configuration from external files.

Commands to Run
cat > application.properties << 'EOF'
app.name=My Web App
app.version=1.0.0
server.port=8080
server.timeout=30
EOF

kubectl create configmap app-properties --from-file=application.properties
kubectl get configmap app-properties -o yaml

What This Does
--from-file loads file contents into ConfigMap. Filename becomes the key, contents become the value.

Expected Outcome
ConfigMap created with application.properties as key containing the file contents.

Pro Tips
1 Great for config files: application.properties, config.json, nginx.conf
2 Filename becomes ConfigMap key by default
3 Override key name: --from-file=mykey=application.properties
4 Can load entire directories: --from-file=config/
5 Files appear as mounted files in containers

Step 3 Use ConfigMap as environment variables
Inject ConfigMap data into pods as environment variables.

Commands to Run
cat > pod-with-config.yaml << 'EOF'
apiVersion: v1
kind: Pod
metadata:
  name: config-pod
spec:
  containers:
  - name: app
    image: alpine:latest
    command: ["sleep", "3600"]
    env:
    - name: APP_ENV
      valueFrom:
        configMapKeyRef:
          name: app-config
          key: APP_ENV
    - name: LOG_LEVEL
      valueFrom:
        configMapKeyRef:
          name: app-config
          key: LOG_LEVEL
EOF

kubectl apply -f pod-with-config.yaml
kubectl exec config-pod -- env | grep -E 'APP_ENV|LOG_LEVEL'

What This Does
configMapKeyRef injects specific ConfigMap keys as environment variables in the container.

Expected Outcome
Pod created. Environment variables show APP_ENV=production and LOG_LEVEL=info.

Pro Tips
1 Each key needs separate env entry
2 Use envFrom to load all keys at once
3 Environment variables set at container start
4 Changes require pod restart to take effect
5 Useful for 12-factor app configuration

Step 4 Mount ConfigMap as volume
Make ConfigMap data available as files in the container.

Commands to Run
cat > pod-with-volume.yaml << 'EOF'
apiVersion: v1
kind: Pod
metadata:
  name: volume-pod
spec:
  containers:
  - name: app
    image: alpine:latest
    command: ["sleep", "3600"]
    volumeMounts:
    - name: config-volume
      mountPath: /etc/config
  volumes:
  - name: config-volume
    configMap:
      name: app-properties
EOF

kubectl apply -f pod-with-volume.yaml
kubectl exec volume-pod -- ls -l /etc/config
kubectl exec volume-pod -- cat /etc/config/application.properties

What This Does
ConfigMap mounted as volume creates files in the container. Each key becomes a file.

Expected Outcome
application.properties file exists at /etc/config/ with correct contents.

Pro Tips
1 Volume mounts are live - updates reflect without restart
2 Each ConfigMap key becomes a file
3 Use mountPath to specify where files appear
4 Can mount specific keys with items: field
5 subPath mounts single file instead of directory

Step 5 Create a Secret
Store sensitive data like passwords and API keys.

Commands to Run
kubectl create secret generic db-secret --from-literal=username=admin --from-literal=password=secretpass123
kubectl get secret db-secret
kubectl get secret db-secret -o yaml

What This Does
Secrets are similar to ConfigMaps but for sensitive data. Values are base64-encoded (not encrypted).

Expected Outcome
Secret created. YAML shows data values are base64-encoded.

Pro Tips
1 Secrets are NOT encrypted by default, only base64-encoded
2 Enable encryption at rest in production clusters
3 Use for: passwords, tokens, SSH keys, TLS certs
4 Three types: generic, docker-registry, tls
5 Secrets can be mounted or used as env vars

Step 6 Use Secrets in pods
Inject sensitive data securely into containers.

Commands to Run
cat > pod-with-secret.yaml << 'EOF'
apiVersion: v1
kind: Pod
metadata:
  name: secret-pod
spec:
  containers:
  - name: app
    image: alpine:latest
    command: ["sleep", "3600"]
    env:
    - name: DB_USERNAME
      valueFrom:
        secretKeyRef:
          name: db-secret
          key: username
    - name: DB_PASSWORD
      valueFrom:
        secretKeyRef:
          name: db-secret
          key: password
EOF

kubectl apply -f pod-with-secret.yaml
kubectl exec secret-pod -- env | grep DB_

What This Does
secretKeyRef injects Secret values as environment variables. Values are decoded automatically.

Expected Outcome
Pod created. Environment variables show decoded secret values.

Pro Tips
1 Secrets automatically decoded when used
2 Env vars are visible in pod spec and logs - be careful
3 Volume mounts are more secure than env vars
4 RBAC controls who can read Secrets
5 Use external secret management in production (Vault, AWS Secrets Manager)

Step 7 Create TLS Secret
Store TLS certificates for HTTPS applications.

Commands to Run
openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout tls.key -out tls.crt -subj '/CN=example.com'
kubectl create secret tls tls-secret --cert=tls.crt --key=tls.key
kubectl describe secret tls-secret

What This Does
TLS secrets store certificate and private key for HTTPS. Used by Ingress controllers.

Expected Outcome
Self-signed certificate created. TLS secret contains tls.crt and tls.key.

Pro Tips
1 TLS secrets have specific keys: tls.crt and tls.key
2 Used primarily with Ingress resources
3 Can also create from PEM files
4 In production, use cert-manager for automatic cert management
5 Store CA certificates separately if needed

Step 8 Update ConfigMap and rollout
Change configuration and propagate to pods.

Commands to Run
kubectl create configmap app-config-v2 --from-literal=APP_ENV=staging --from-literal=LOG_LEVEL=debug
kubectl create deployment config-app --image=alpine:latest --replicas=2 -- sleep 3600
kubectl set env deployment/config-app --from=configmap/app-config-v2
kubectl rollout status deployment/config-app

What This Does
Update ConfigMap reference in Deployment. Triggers rolling update to apply new configuration.

Expected Outcome
Deployment updates with new ConfigMap. Pods restart with new configuration.

Pro Tips
1 Changing ConfigMap doesn't auto-update pods using env vars
2 Volume-mounted ConfigMaps update automatically (with delay)
3 Best practice: create new ConfigMap version, update Deployment
4 Or use annotations to trigger rollout
5 Consider using GitOps for config management

Step 9 Use envFrom to load all keys
Load entire ConfigMap or Secret as environment variables.

Commands to Run
cat > pod-envfrom.yaml << 'EOF'
apiVersion: v1
kind: Pod
metadata:
  name: envfrom-pod
spec:
  containers:
  - name: app
    image: alpine:latest
    command: ["sleep", "3600"]
    envFrom:
    - configMapRef:
        name: app-config
    - secretRef:
        name: db-secret
EOF

kubectl apply -f pod-envfrom.yaml
kubectl exec envfrom-pod -- env | sort

What This Does
envFrom loads all keys from ConfigMap or Secret as environment variables. Simpler than individual mappings.

Expected Outcome
All keys from app-config and db-secret appear as environment variables.

Pro Tips
1 envFrom loads all keys at once
2 Key names become env var names directly
3 Can prefix keys: envFrom with prefix: MY_PREFIX_
4 Useful when you want all config as env vars
5 Invalid env var names are skipped

Step 10 Clean up resources
Delete ConfigMaps, Secrets, and pods.

Commands to Run
kubectl delete configmap app-config app-properties app-config-v2
kubectl delete secret db-secret tls-secret
kubectl delete pod config-pod volume-pod secret-pod envfrom-pod
kubectl delete deployment config-app
rm -f tls.crt tls.key application.properties *.yaml

What This Does
Clean up all created resources and local files.

Expected Outcome
All ConfigMaps, Secrets, Pods, and Deployments deleted. Local files removed.

Pro Tips
1 ConfigMaps and Secrets don't get deleted with pods
2 Always clean up unused configs to avoid clutter
3 In production, use kubectl delete -f [files]
4 Version control your configuration files
5 Consider using Helm or Kustomize for config management

✓ Create ConfigMaps from literals and files
✓ Manage sensitive data with Secrets
✓ Inject configurations as environment variables and volumes
✓ Update configurations without rebuilding images
✓ Work with TLS certificates
